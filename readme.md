## JWT guard

2 типа токенов:
 1. auth token - позваляет авторизоватся на сервисе, нельзя никак заблокировать такой токен, а потому он должен иметь не длительное время жизни. Для авторизации требует всего один запрос к БД (к таблице users)
 2. refresh token -  позволяет аутентифицироваться в системе, можно заблокировать такой токен, так как он выдается на основе remember_token, хранящегося в БД, требует два запроса к БД  (к таблицам users, users_tokens)


#### Конфигурация

**config/auth.php**

```php
['guards' => [
        'api' => [  // название вашего защитника, можете указать любое, главное что бы оно же было в секции "defaults"
            'driver' => 'jwt', // обязательно укажите название драйвера "jwt"
            'provider' => 'users', // провайдер, название секции из "providers"
            'config' => [
                'authToken' => [
                    'verifyKey' => env('JWT_AUTH_KEY'), // ключ, которым будут подписыватся токены авторизации
                    'life' => 43200, // время жизни токенов авторизации
                ],
                'refreshToken' => [
                    'verifyKey' => env('JWT_REFRESH_KEY'), // ключ, которым будут подписыватся токены обновления 
                    'life' => 2592000,  // время жизни токенов обновления
                ],
                'guest' => [ // в этой секции возможно указать Eloquent Model и ее ID, она будет возвращаться, когда никакой пользователь не авторизован в системе. Если здесь указано false, будет возвращаться null (как стандартно в Laravel)
                    'id' => 1,
                    'model' => App\Models\User::class,
                ],
            ]
        ],
    ]
]
```
#### Методы

 1. **login($user)** - авторизровать пользователя по его Eloquent Model
 2. **loginByCredentials($credentials)** - аутентифицировать пользователя на основе его учетных данных 
 3. **loginByToken($token)** - авторизовать пользователя на основе auth token
 4. **loginByRefreshToken($token)** - аутентифицировать пользователя на основе refresh token
 5. **loginByRequest($request = null)** - авторизовать пользователя на основе заголовка Authorization в запросе. Если не передан аргумент $request, проверка идет для текущего запроса

 6. **createAuthToken($user = null)** - выписать токен авторизации для пользователя. Если не указан $user, токен выписывается для авторизованногов системе пользователя
 7. **createRefreshToken($user = null)** - выписать токен обновления для пользователя. Если не указан $user, токен выписывается для авторизованногов системе пользователя
 8. **updateRefreshToken($token)** - обновить токен обновления для пользователя. Отличие от createRefreshToken() в том, что не создается новая строка в БД, только меняется remember token. Эта разница заметна только с провайдером EloquentTokenUserProvider этого же пакета

#### Guest

Если в конфигурации указана секция "guest", то в случае, если ни один пользователь не авторизован в системе, будет возвращаться не null при попытке его получить, а указанная в этой секции Eloquent Model.

## EloquentTokenUser Provider

2 таблицы (модели)
 1. user - для хранения пользователей
 2. tokens - для хранения токенов, по которым пользователи могут аутентифироваться в длительной перспективе

 #### Конфигурация

**config/auth.php**

```php
 ['providers' => [
        'users' => [  // название вашего провайдера, можете указать любое, главное что бы оно же было в секции "guards"
            'driver' => 'eloquent-tokens', // обязательно укажите название драйвера "eloquent-tokens"
            'models' => [
                'user' => App\Models\User::class, // модель, в которой хрянятся пользоавтели
                'token' => App\Models\UserToken::class, // модель, в которой хрянятся токены пользователей
            ],
        ],
    ],
]
```